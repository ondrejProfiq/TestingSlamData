'use strict';

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var _appiumSupport = require('appium-support');

var _appiumXcode = require('appium-xcode');

var _appiumXcode2 = _interopRequireDefault(_appiumXcode);

var _teen_process = require('teen_process');

var START_TIMEOUT = 10000;
var DEVICE_CONSOLE_PATH = _path2['default'].resolve(__dirname, '..', '..', '..', 'build', 'deviceconsole');
var SYSTEM_LOG_PATH = '/var/log/system.log';
// We keep only the most recent log entries to avoid out of memory error
var MAX_LOG_ENTRIES_COUNT = 10000;

var IOSLog = (function () {
  function IOSLog(opts) {
    _classCallCheck(this, IOSLog);

    this.sim = opts.sim;
    this.udid = opts.udid;
    this.showLogs = !!opts.showLogs;

    this.proc = null;
    this.logs = [];
    this.logRow = '';
    this.logIdxSinceLastRequest = -1;
    this.maxBufferSize = MAX_LOG_ENTRIES_COUNT;
  }

  _createClass(IOSLog, [{
    key: 'startCaptureRealDevice',
    value: function startCaptureRealDevice() {
      var spawnEnv, idevicesyslog;
      return _regeneratorRuntime.async(function startCaptureRealDevice$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            spawnEnv = _lodash2['default'].clone(process.env);

            _logger2['default'].debug('Attempting iOS device log capture via libimobiledevice idevicesyslog');
            context$2$0.prev = 2;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.which('idevicesyslog'));

          case 5:
            idevicesyslog = context$2$0.sent;

            _logger2['default'].debug('Found idevicesyslog: \'' + idevicesyslog + '\'');
            this.proc = new _teen_process.SubProcess('idevicesyslog', ['-u', this.udid], { env: spawnEnv });
            context$2$0.next = 17;
            break;

          case 10:
            context$2$0.prev = 10;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].warn('Could not capture device log using libimobiledevice idevicesyslog. ' + 'Libimobiledevice is probably not installed');
            _logger2['default'].debug('Attempting iOS device log capture via deviceconsole');
            spawnEnv.PATH = process.env.PATH + ':' + DEVICE_CONSOLE_PATH;
            spawnEnv.DYLD_LIBRARY_PATH = DEVICE_CONSOLE_PATH + ':' + process.env.DYLD_LIBRARY_PATH;
            this.proc = new _teen_process.SubProcess('deviceconsole', ['-u', this.udid], { env: spawnEnv });

          case 17:
            context$2$0.next = 19;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 10]]);
    }
  }, {
    key: 'startCapture',
    value: function startCapture() {
      var xCodeVersion, logPath, systemLogPath, files, lastModifiedLogPath, lastModifiedLogTime, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, file, mtime;

      return _regeneratorRuntime.async(function startCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.udid) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', this.startCaptureRealDevice());

          case 2:
            context$2$0.next = 4;
            return _regeneratorRuntime.awrap(_appiumXcode2['default'].getVersion(true));

          case 4:
            xCodeVersion = context$2$0.sent;
            context$2$0.t0 = _logger2['default'];
            context$2$0.next = 8;
            return _regeneratorRuntime.awrap(this.sim.getPlatformVersion());

          case 8:
            context$2$0.t1 = context$2$0.sent;
            context$2$0.t2 = 'Starting iOS ' + context$2$0.t1;
            context$2$0.t3 = context$2$0.t2 + ' simulator log capture';
            context$2$0.t0.debug.call(context$2$0.t0, context$2$0.t3);

            if (!(xCodeVersion.major < 5)) {
              context$2$0.next = 17;
              break;
            }

            this.proc = new _teen_process.SubProcess('tail', ['-f', '-n', '1', SYSTEM_LOG_PATH]);
            context$2$0.next = 16;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 16:
            return context$2$0.abrupt('return');

          case 17:

            // this is xcode 6+
            if (_lodash2['default'].isUndefined(this.sim.udid)) {
              _logger2['default'].errorAndThrow('iOS ' + xCodeVersion.versionString + ' log capture requires a sim udid');
            }

            logPath = this.sim.getLogDir();
            context$2$0.prev = 19;

            if (!(logPath.indexOf('*') >= 0)) {
              context$2$0.next = 23;
              break;
            }

            _logger2['default'].error('Log path has * in it. Unable to start log capture: ' + logPath);
            return context$2$0.abrupt('return');

          case 23:
            systemLogPath = _path2['default'].resolve(logPath, 'system.log');

            _logger2['default'].debug('System log path: ' + systemLogPath);
            context$2$0.next = 27;
            return _regeneratorRuntime.awrap((0, _appiumSupport.mkdirp)(logPath));

          case 27:
            context$2$0.next = 29;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.writeFile(systemLogPath, 'A new Appium session is about to start!\n', { flag: 'a' }));

          case 29:
            files = undefined;
            context$2$0.prev = 30;
            context$2$0.next = 33;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.glob(systemLogPath));

          case 33:
            files = context$2$0.sent;

            if (!(files.length < 1)) {
              context$2$0.next = 36;
              break;
            }

            throw new Error('Could not start log capture');

          case 36:
            context$2$0.next = 41;
            break;

          case 38:
            context$2$0.prev = 38;
            context$2$0.t4 = context$2$0['catch'](30);

            _logger2['default'].error('Could not start log capture because no iOS ' + ('simulator logs could be found at ' + systemLogPath + '. ') + 'Logging will not be functional for this run');

          case 41:
            lastModifiedLogPath = files[0];
            context$2$0.next = 44;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(lastModifiedLogPath).mtime);

          case 44:
            lastModifiedLogTime = context$2$0.sent;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$2$0.prev = 48;
            _iterator = _getIterator(files);

          case 50:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$2$0.next = 59;
              break;
            }

            file = _step.value;
            context$2$0.next = 54;
            return _regeneratorRuntime.awrap(_appiumSupport.fs.stat(file).mtime);

          case 54:
            mtime = context$2$0.sent;

            if (mtime > lastModifiedLogTime) {
              lastModifiedLogPath = file;
              lastModifiedLogTime = mtime;
            }

          case 56:
            _iteratorNormalCompletion = true;
            context$2$0.next = 50;
            break;

          case 59:
            context$2$0.next = 65;
            break;

          case 61:
            context$2$0.prev = 61;
            context$2$0.t5 = context$2$0['catch'](48);
            _didIteratorError = true;
            _iteratorError = context$2$0.t5;

          case 65:
            context$2$0.prev = 65;
            context$2$0.prev = 66;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 68:
            context$2$0.prev = 68;

            if (!_didIteratorError) {
              context$2$0.next = 71;
              break;
            }

            throw _iteratorError;

          case 71:
            return context$2$0.finish(68);

          case 72:
            return context$2$0.finish(65);

          case 73:
            this.proc = new _teen_process.SubProcess('tail', ['-f', '-n', '1', lastModifiedLogPath]);
            context$2$0.next = 76;
            return _regeneratorRuntime.awrap(this.finishStartingLogCapture());

          case 76:
            context$2$0.next = 81;
            break;

          case 78:
            context$2$0.prev = 78;
            context$2$0.t6 = context$2$0['catch'](19);

            _logger2['default'].errorAndThrow('System log capture failed: ' + context$2$0.t6.message);

          case 81:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[19, 78], [30, 38], [48, 61, 65, 73], [66,, 68, 72]]);
    }
  }, {
    key: 'finishStartingLogCapture',
    value: function finishStartingLogCapture() {
      var firstLine, sd;
      return _regeneratorRuntime.async(function finishStartingLogCapture$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.proc) {
              _logger2['default'].errorAndThrow('Could not capture device log');
            }
            firstLine = true;

            this.proc.on('output', function (stdout, stderr) {
              if (stdout) {
                if (firstLine) {
                  if (stdout.substr(-1, 1) === '\n') {
                    // don't store the first line of the log because it came before the sim or device was launched
                    firstLine = false;
                  }
                } else {
                  _this.logRow += stdout;
                  if (stdout.substr(-1, 1) === '\n') {
                    _this.onOutput();
                    _this.logRow = '';
                  }
                }
              }
              if (stderr) {
                _this.onOutput('STDERR');
              }
            });

            sd = function sd(stdout, stderr) {
              if (/execvp\(\)/.test(stderr)) {
                throw new Error('iOS log capture process failed to start');
              }
              return stdout || stderr;
            };

            context$2$0.next = 6;
            return _regeneratorRuntime.awrap(this.proc.start(sd, START_TIMEOUT));

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'stopCapture',
    value: function stopCapture() {
      return _regeneratorRuntime.async(function stopCapture$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            _logger2['default'].debug('Stopping iOS log capture');

            if (!(this.proc && this.proc.isRunning)) {
              context$2$0.next = 12;
              break;
            }

            context$2$0.prev = 2;
            context$2$0.next = 5;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGTERM', 1000));

          case 5:
            context$2$0.next = 12;
            break;

          case 7:
            context$2$0.prev = 7;
            context$2$0.t0 = context$2$0['catch'](2);

            _logger2['default'].error('Cannot stop log capture process. Sending SIGKILL...');
            context$2$0.next = 12;
            return _regeneratorRuntime.awrap(this.proc.stop('SIGKILL'));

          case 12:
            this.proc = null;

          case 13:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[2, 7]]);
    }
  }, {
    key: 'onOutput',
    value: function onOutput() {
      var prefix = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];

      var logs = this.logRow.split('\n');
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _getIterator(logs), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var log = _step2.value;

          if (!log) continue;
          var logObj = {
            timestamp: Date.now(),
            level: 'ALL',
            message: log
          };
          this.logs.push(logObj);
          if (this.logs.length > this.maxBufferSize) {
            this.logs.shift();
            if (this.logIdxSinceLastRequest > 0) {
              --this.logIdxSinceLastRequest;
            }
          }
          if (this.showLogs) {
            var space = prefix.length > 0 ? ' ' : '';
            _logger2['default'].info('[IOS_SYSLOG_ROW' + space + prefix + '] ' + log);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2['return']) {
            _iterator2['return']();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'getLogs',
    value: function getLogs() {
      var result;
      return _regeneratorRuntime.async(function getLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!(this.logs.length && this.logIdxSinceLastRequest < this.logs.length)) {
              context$2$0.next = 5;
              break;
            }

            result = this.logs;

            if (this.logIdxSinceLastRequest > 0) {
              result = result.slice(this.logIdxSinceLastRequest);
            }
            this.logIdxSinceLastRequest = this.logs.length;
            return context$2$0.abrupt('return', result);

          case 5:
            return context$2$0.abrupt('return', []);

          case 6:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'getAllLogs',
    value: function getAllLogs() {
      return _regeneratorRuntime.async(function getAllLogs$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            return context$2$0.abrupt('return', this.logs);

          case 1:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return IOSLog;
})();

exports.IOSLog = IOSLog;
exports['default'] = IOSLog;
// if we have a real device

// otherwise, if we have a simulator...
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kZXZpY2UtbG9nL2lvcy1sb2cuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztvQkFBaUIsTUFBTTs7OztzQkFDVCxRQUFROzs7O3NCQUNILFVBQVU7Ozs7NkJBQ0YsZ0JBQWdCOzsyQkFDekIsY0FBYzs7Ozs0QkFDTCxjQUFjOztBQUV6QyxJQUFNLGFBQWEsR0FBRyxLQUFLLENBQUM7QUFDNUIsSUFBTSxtQkFBbUIsR0FBRyxrQkFBSyxPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztBQUNoRyxJQUFNLGVBQWUsR0FBRyxxQkFBcUIsQ0FBQzs7QUFFOUMsSUFBTSxxQkFBcUIsR0FBRyxLQUFLLENBQUM7O0lBRTlCLE1BQU07QUFDRSxXQURSLE1BQU0sQ0FDRyxJQUFJLEVBQUU7MEJBRGYsTUFBTTs7QUFFUixRQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7QUFDcEIsUUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQ3RCLFFBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7O0FBRWhDLFFBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLFFBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ2YsUUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDakIsUUFBSSxDQUFDLHNCQUFzQixHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2pDLFFBQUksQ0FBQyxhQUFhLEdBQUcscUJBQXFCLENBQUM7R0FDNUM7O2VBWEcsTUFBTTs7V0FhbUI7VUFDdkIsUUFBUSxFQUdOLGFBQWE7Ozs7QUFIZixvQkFBUSxHQUFHLG9CQUFFLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDOztBQUNuQyxnQ0FBTyxLQUFLLENBQUMsc0VBQXNFLENB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Ozs7OztLQUNWOzs7V0FFZ0I7Ozs7Z0RBQ1IsSUFBSSxDQUFDLElBQUk7Ozs7Ozs7S0FDakI7OztTQTVLRyxNQUFNOzs7UUErS0gsTUFBTSxHQUFOLE1BQU07cUJBQ0EsTUFBTSIsImZpbGUiOiJsaWIvZGV2aWNlLWxvZy9pb3MtbG9nLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBmcywgbWtkaXJwIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHhjb2RlIGZyb20gJ2FwcGl1bS14Y29kZSc7XG5pbXBvcnQgeyBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcblxuY29uc3QgU1RBUlRfVElNRU9VVCA9IDEwMDAwO1xuY29uc3QgREVWSUNFX0NPTlNPTEVfUEFUSCA9IHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLicsICcuLicsICcuLicsICdidWlsZCcsICdkZXZpY2Vjb25zb2xlJyk7XG5jb25zdCBTWVNURU1fTE9HX1BBVEggPSAnL3Zhci9sb2cvc3lzdGVtLmxvZyc7XG4vLyBXZSBrZWVwIG9ubHkgdGhlIG1vc3QgcmVjZW50IGxvZyBlbnRyaWVzIHRvIGF2b2lkIG91dCBvZiBtZW1vcnkgZXJyb3JcbmNvbnN0IE1BWF9MT0dfRU5UUklFU19DT1VOVCA9IDEwMDAwO1xuXG5jbGFzcyBJT1NMb2cge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMuc2ltID0gb3B0cy5zaW07XG4gICAgdGhpcy51ZGlkID0gb3B0cy51ZGlkO1xuICAgIHRoaXMuc2hvd0xvZ3MgPSAhIW9wdHMuc2hvd0xvZ3M7XG5cbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMubG9ncyA9IFtdO1xuICAgIHRoaXMubG9nUm93ID0gJyc7XG4gICAgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID0gLTE7XG4gICAgdGhpcy5tYXhCdWZmZXJTaXplID0gTUFYX0xPR19FTlRSSUVTX0NPVU5UO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRDYXB0dXJlUmVhbERldmljZSAoKSB7XG4gICAgbGV0IHNwYXduRW52ID0gXy5jbG9uZShwcm9jZXNzLmVudik7XG4gICAgbG9nZ2VyLmRlYnVnKCdBdHRlbXB0aW5nIGlPUyBkZXZpY2UgbG9nIGNhcHR1cmUgdmlhIGxpYmltb2JpbGVkZXZpY2UgaWRldmljZXN5c2xvZycpO1xuICAgIHRyeSB7XG4gICAgICBsZXQgaWRldmljZXN5c2xvZyA9IGF3YWl0IGZzLndoaWNoKCdpZGV2aWNlc3lzbG9nJyk7XG4gICAgICBsb2dnZXIuZGVidWcoYEZvdW5kIGlkZXZpY2VzeXNsb2c6ICcke2lkZXZpY2VzeXNsb2d9J2ApO1xuICAgICAgdGhpcy5wcm9jID0gbmV3IFN1YlByb2Nlc3MoJ2lkZXZpY2VzeXNsb2cnLCBbJy11JywgdGhpcy51ZGlkXSwge2Vudjogc3Bhd25FbnZ9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZ2dlci53YXJuKCdDb3VsZCBub3QgY2FwdHVyZSBkZXZpY2UgbG9nIHVzaW5nIGxpYmltb2JpbGVkZXZpY2UgaWRldmljZXN5c2xvZy4gJyArXG4gICAgICAgICAgICAgICAgICAnTGliaW1vYmlsZWRldmljZSBpcyBwcm9iYWJseSBub3QgaW5zdGFsbGVkJyk7XG4gICAgICBsb2dnZXIuZGVidWcoJ0F0dGVtcHRpbmcgaU9TIGRldmljZSBsb2cgY2FwdHVyZSB2aWEgZGV2aWNlY29uc29sZScpO1xuICAgICAgc3Bhd25FbnYuUEFUSCA9IGAke3Byb2Nlc3MuZW52LlBBVEh9OiR7REVWSUNFX0NPTlNPTEVfUEFUSH1gO1xuICAgICAgc3Bhd25FbnYuRFlMRF9MSUJSQVJZX1BBVEggPSBgJHtERVZJQ0VfQ09OU09MRV9QQVRIfToke3Byb2Nlc3MuZW52LkRZTERfTElCUkFSWV9QQVRIfWA7XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2VzcygnZGV2aWNlY29uc29sZScsIFsnLXUnLCB0aGlzLnVkaWRdLCB7ZW52OiBzcGF3bkVudn0pO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmZpbmlzaFN0YXJ0aW5nTG9nQ2FwdHVyZSgpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRDYXB0dXJlICgpIHtcbiAgICBpZiAodGhpcy51ZGlkKSB7IC8vIGlmIHdlIGhhdmUgYSByZWFsIGRldmljZVxuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRDYXB0dXJlUmVhbERldmljZSgpO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIGlmIHdlIGhhdmUgYSBzaW11bGF0b3IuLi5cbiAgICBsZXQgeENvZGVWZXJzaW9uID0gYXdhaXQgeGNvZGUuZ2V0VmVyc2lvbih0cnVlKTtcblxuICAgIGxvZ2dlci5kZWJ1ZyhgU3RhcnRpbmcgaU9TICR7YXdhaXQgdGhpcy5zaW0uZ2V0UGxhdGZvcm1WZXJzaW9uKCl9IHNpbXVsYXRvciBsb2cgY2FwdHVyZWApO1xuICAgIGlmICh4Q29kZVZlcnNpb24ubWFqb3IgPCA1KSB7XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2VzcygndGFpbCcsIFsnLWYnLCAnLW4nLCAnMScsIFNZU1RFTV9MT0dfUEFUSF0pO1xuICAgICAgYXdhaXQgdGhpcy5maW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGlzIHhjb2RlIDYrXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy5zaW0udWRpZCkpIHtcbiAgICAgIGxvZ2dlci5lcnJvckFuZFRocm93KGBpT1MgJHt4Q29kZVZlcnNpb24udmVyc2lvblN0cmluZ30gbG9nIGNhcHR1cmUgcmVxdWlyZXMgYSBzaW0gdWRpZGApO1xuICAgIH1cblxuICAgIGxldCBsb2dQYXRoID0gdGhpcy5zaW0uZ2V0TG9nRGlyKCk7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsb2dQYXRoLmluZGV4T2YoJyonKSA+PSAwKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgTG9nIHBhdGggaGFzICogaW4gaXQuIFVuYWJsZSB0byBzdGFydCBsb2cgY2FwdHVyZTogJHtsb2dQYXRofWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3lzdGVtTG9nUGF0aCA9IHBhdGgucmVzb2x2ZShsb2dQYXRoLCAnc3lzdGVtLmxvZycpO1xuICAgICAgbG9nZ2VyLmRlYnVnKGBTeXN0ZW0gbG9nIHBhdGg6ICR7c3lzdGVtTG9nUGF0aH1gKTtcbiAgICAgIGF3YWl0IG1rZGlycChsb2dQYXRoKTtcbiAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShzeXN0ZW1Mb2dQYXRoLCAnQSBuZXcgQXBwaXVtIHNlc3Npb24gaXMgYWJvdXQgdG8gc3RhcnQhXFxuJywge2ZsYWc6ICdhJ30pO1xuICAgICAgbGV0IGZpbGVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZXMgPSBhd2FpdCBmcy5nbG9iKHN5c3RlbUxvZ1BhdGgpO1xuICAgICAgICBpZiAoZmlsZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHN0YXJ0IGxvZyBjYXB0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBDb3VsZCBub3Qgc3RhcnQgbG9nIGNhcHR1cmUgYmVjYXVzZSBubyBpT1MgYCArXG4gICAgICAgICAgICAgICAgICAgICBgc2ltdWxhdG9yIGxvZ3MgY291bGQgYmUgZm91bmQgYXQgJHtzeXN0ZW1Mb2dQYXRofS4gYCArXG4gICAgICAgICAgICAgICAgICAgICBgTG9nZ2luZyB3aWxsIG5vdCBiZSBmdW5jdGlvbmFsIGZvciB0aGlzIHJ1bmApO1xuICAgICAgfVxuXG4gICAgICBsZXQgbGFzdE1vZGlmaWVkTG9nUGF0aCA9IGZpbGVzWzBdO1xuICAgICAgbGV0IGxhc3RNb2RpZmllZExvZ1RpbWUgPSBhd2FpdCBmcy5zdGF0KGxhc3RNb2RpZmllZExvZ1BhdGgpLm10aW1lO1xuICAgICAgZm9yIChsZXQgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICBsZXQgbXRpbWUgPSBhd2FpdCBmcy5zdGF0KGZpbGUpLm10aW1lO1xuICAgICAgICBpZiAobXRpbWUgPiBsYXN0TW9kaWZpZWRMb2dUaW1lKSB7XG4gICAgICAgICAgbGFzdE1vZGlmaWVkTG9nUGF0aCA9IGZpbGU7XG4gICAgICAgICAgbGFzdE1vZGlmaWVkTG9nVGltZSA9IG10aW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnByb2MgPSBuZXcgU3ViUHJvY2VzcygndGFpbCcsIFsnLWYnLCAnLW4nLCAnMScsIGxhc3RNb2RpZmllZExvZ1BhdGhdKTtcbiAgICAgIGF3YWl0IHRoaXMuZmluaXNoU3RhcnRpbmdMb2dDYXB0dXJlKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3JBbmRUaHJvdyhgU3lzdGVtIGxvZyBjYXB0dXJlIGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmaW5pc2hTdGFydGluZ0xvZ0NhcHR1cmUgKCkge1xuICAgIGlmICghdGhpcy5wcm9jKSB7XG4gICAgICBsb2dnZXIuZXJyb3JBbmRUaHJvdygnQ291bGQgbm90IGNhcHR1cmUgZGV2aWNlIGxvZycpO1xuICAgIH1cbiAgICBsZXQgZmlyc3RMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLnByb2Mub24oJ291dHB1dCcsIChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgaWYgKHN0ZG91dCkge1xuICAgICAgICBpZiAoZmlyc3RMaW5lKSB7XG4gICAgICAgICAgaWYgKHN0ZG91dC5zdWJzdHIoLTEsIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgLy8gZG9uJ3Qgc3RvcmUgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIGxvZyBiZWNhdXNlIGl0IGNhbWUgYmVmb3JlIHRoZSBzaW0gb3IgZGV2aWNlIHdhcyBsYXVuY2hlZFxuICAgICAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nUm93ICs9IHN0ZG91dDtcbiAgICAgICAgICBpZiAoc3Rkb3V0LnN1YnN0cigtMSwgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICB0aGlzLm9uT3V0cHV0KCk7XG4gICAgICAgICAgICB0aGlzLmxvZ1JvdyA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0ZGVycikge1xuICAgICAgICB0aGlzLm9uT3V0cHV0KCdTVERFUlInKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxldCBzZCA9IChzdGRvdXQsIHN0ZGVycikgPT4ge1xuICAgICAgaWYgKC9leGVjdnBcXChcXCkvLnRlc3Qoc3RkZXJyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lPUyBsb2cgY2FwdHVyZSBwcm9jZXNzIGZhaWxlZCB0byBzdGFydCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ZG91dCB8fCBzdGRlcnI7XG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLnByb2Muc3RhcnQoc2QsIFNUQVJUX1RJTUVPVVQpO1xuICB9XG5cbiAgYXN5bmMgc3RvcENhcHR1cmUgKCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnU3RvcHBpbmcgaU9TIGxvZyBjYXB0dXJlJyk7XG4gICAgaWYgKHRoaXMucHJvYyAmJiB0aGlzLnByb2MuaXNSdW5uaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgnU0lHVEVSTScsIDEwMDApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0Nhbm5vdCBzdG9wIGxvZyBjYXB0dXJlIHByb2Nlc3MuIFNlbmRpbmcgU0lHS0lMTC4uLicpO1xuICAgICAgICBhd2FpdCB0aGlzLnByb2Muc3RvcCgnU0lHS0lMTCcpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICB9XG5cbiAgb25PdXRwdXQgKHByZWZpeCA9ICcnKSB7XG4gICAgbGV0IGxvZ3MgPSB0aGlzLmxvZ1Jvdy5zcGxpdCgnXFxuJyk7XG4gICAgZm9yIChsZXQgbG9nIG9mIGxvZ3MpIHtcbiAgICAgIGlmICghbG9nKSBjb250aW51ZTtcbiAgICAgIGxldCBsb2dPYmogPSB7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgbGV2ZWw6ICdBTEwnLFxuICAgICAgICBtZXNzYWdlOiBsb2dcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZ3MucHVzaChsb2dPYmopO1xuICAgICAgaWYgKHRoaXMubG9ncy5sZW5ndGggPiB0aGlzLm1heEJ1ZmZlclNpemUpIHtcbiAgICAgICAgdGhpcy5sb2dzLnNoaWZ0KCk7XG4gICAgICAgIGlmICh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPiAwKSB7XG4gICAgICAgICAgLS10aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNob3dMb2dzKSB7XG4gICAgICAgIGxldCBzcGFjZSA9IHByZWZpeC5sZW5ndGggPiAwID8gJyAnIDogJyc7XG4gICAgICAgIGxvZ2dlci5pbmZvKGBbSU9TX1NZU0xPR19ST1cke3NwYWNlfSR7cHJlZml4fV0gJHtsb2d9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0TG9ncyAoKSB7XG4gICAgaWYgKHRoaXMubG9ncy5sZW5ndGggJiYgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0IDwgdGhpcy5sb2dzLmxlbmd0aCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubG9ncztcbiAgICAgIGlmICh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QgPiAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSh0aGlzLmxvZ0lkeFNpbmNlTGFzdFJlcXVlc3QpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2dJZHhTaW5jZUxhc3RSZXF1ZXN0ID0gdGhpcy5sb2dzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGFzeW5jIGdldEFsbExvZ3MgKCkge1xuICAgIHJldHVybiB0aGlzLmxvZ3M7XG4gIH1cbn1cblxuZXhwb3J0IHsgSU9TTG9nIH07XG5leHBvcnQgZGVmYXVsdCBJT1NMb2c7XG4iXSwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
